<!doctype html>
<html lang="en">

<head>
    <meta charset="utf-8" />
    <title>Cosmic Constellation</title>
    <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
    <style>
        :root {
            color-scheme: dark;
        }

        html,
        body {
            margin: 0;
            height: 100%;
            background: #0b0e19;
            font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
            color: #e8ecff;
            overflow: hidden;
            /* prevent scroll bounce on mobile */
        }

        #wrap {
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        /* JS now sizes the canvas; these are fallbacks */
        #game {
            width: 800px;
            height: 600px;
            display: block;
            border: 3px solid #1b2440;
            background: #090c16;
            touch-action: manipulation;
            /* better taps */
        }

        .btn {
            position: fixed;
            top: 12px;
            padding: 8px 12px;
            border-radius: 12px;
            border: 1px solid #2d3340;
            background: #161c2e;
            color: #e8eaf0;
            font-weight: 600;
            cursor: pointer;
            z-index: 10;
            box-shadow: 0 2px 10px rgba(0, 0, 0, .35);
        }

        #reset {
            left: 12px;
        }

        #mute {
            left: 104px;
        }

        #hud {
            position: fixed;
            top: 12px;
            left: 180px;
            right: 12px;
            display: flex;
            gap: 16px;
            align-items: center;
            opacity: .9;
            text-shadow: 0 1px 2px rgba(0, 0, 0, .5);
            pointer-events: none;
            z-index: 9;
            font-size: 14px;
        }

        /* Small screens: stack buttons, keep HUD readable */
        @media (max-width: 480px) {
            #reset {
                top: 8px;
                left: 8px;
            }

            #mute {
                top: 52px;
                left: 8px;
            }

            #hud {
                left: 8px;
                right: 8px;
                font-size: 13px;
            }
        }
    </style>
</head>

<body>
    <button id="reset" class="btn" type="button">Reset</button>
    <button id="mute" class="btn" type="button">ðŸ”Š</button>

    <div id="hud">
        <span id="msg">Wake up all the planets! Tap a planet to toggle it and its neighbors.</span>
        <span id="status"></span>
    </div>

    <div id="wrap">
        <canvas id="game" aria-label="Cosmic Constellation"></canvas>
    </div>

    <script>
        // ---------- Responsive canvas & DPI ----------
        let W = 800, H = 600;
        let DPR = Math.max(1, Math.min(2, window.devicePixelRatio || 1)); // cap at 2 for performance
        const canvas = document.getElementById("game");
        const ctx = canvas.getContext("2d");

        const CENTER = { x: 0, y: 0 }; // set in resizeCanvas()
        let PLANET_R = 22;             // scaled in resizeCanvas()

        function recomputePlanetR() {
            const base = 22; // looks good at 800x600
            const scale = Math.min(W / 800, H / 600);
            PLANET_R = Math.max(18, Math.min(36, Math.round(base * scale)));
        }

        function resizeCanvas() {
            const cssW = Math.max(320, Math.floor(window.innerWidth));
            const cssH = Math.max(280, Math.floor(window.innerHeight));
            W = cssW; H = cssH;

            // Clamp DPR for perf on very high-DPI screens
            DPR = Math.max(1, Math.min(2, window.devicePixelRatio || 1));

            // Backing store size
            canvas.style.width = cssW + "px";
            canvas.style.height = cssH + "px";
            canvas.width = Math.floor(cssW * DPR);
            canvas.height = Math.floor(cssH * DPR);

            // Map drawing units to CSS pixels
            ctx.setTransform(DPR, 0, 0, DPR, 0, 0);

            // Layout recompute
            CENTER.x = W / 2;
            CENTER.y = H / 2;
            RING_RADIUS = clampRadius();
            recomputePlanetR();
            ARROW_W = Math.max(40, Math.min(56, W * 0.06));
            ARROW_H = Math.max(70, Math.min(100, H * 0.18));
            computePositions();

            // Rebuild star field to match new size/density
            initStars();
        }

        // ---------- Config ----------
        const EDGE_COLOR = "rgba(120,170,255,0.35)";
        const SHAKE_FOR = 90;
        const MAX_PARTICLES = 1200;
        const LEVELS = [6, 7];
        const NEIGHBOR_DELAY_MS = 260;

        // Arrow hit areas
        // Arrow hit areas (scale with screen)
        let ARROW_W = Math.max(40, Math.min(56, W * 0.06));
        let ARROW_H = Math.max(70, Math.min(100, H * 0.18));
        const ARROW_PAD = 16;

        // Colors
        const COLOR_ON_BASE = "#ffb36b";
        const COLOR_ON_DEEP = "#ff7a3a";
        const COLOR_OFF_BASE = "#7db6ff";
        const COLOR_OFF_DEEP = "#3c7fe0";

        // Emojis / Names
        const EMOJI_ON = ["ðŸ˜Š", "ðŸ˜º", "âœ¨", "â­ï¸", "ðŸ˜¸", "ðŸ˜ƒ", "ðŸŒŸ"];
        const EMOJI_OFF = ["ðŸ˜´", "ðŸ¥¶", "ðŸŒ™", "ðŸ˜ª", "ðŸ˜¶â€ðŸŒ«ï¸", "ðŸ˜Œ", "â˜ï¸"];
        const NAMES = ["Nova", "Bloop", "Zippy", "Cosmo", "Luna", "Pip", "Comet", "Vivi", "Rex", "Momo"];

        // DOM
        const resetBtn = document.getElementById("reset");
        const muteBtn = document.getElementById("mute");
        const statusEl = document.getElementById("status");
        const msgEl = document.getElementById("msg");

        // ---------- State ----------
        const PAD = 40, LABEL_SPACE = 24;
        let levelIndex = 0;
        let NUM_NODES = LEVELS[levelIndex];
        let RING_RADIUS = clampRadius();

        let nodes = new Array(NUM_NODES).fill(0); // 0=OFF,1=ON
        let positions = [];
        let planetNames = [];
        let completed = false;
        let moves = 0;
        let shakeT = 0;

        // FX
        const shockwaves = [];
        const sparks = [];
        const stars = [];
        let t = 0;

        // Completion radiating rings (centered)
        const winRings = [];

        // Edge pulses (visual; logic delayed by setTimeout)
        let pulses = [];

        // Audio
        const AC = window.AudioContext ? new (window.AudioContext || window.webkitAudioContext)() : null;
        let mute = false;
        function resumeAC() { if (AC && AC.state === "suspended") AC.resume().catch(() => { }); }
        function beep(freq = 440, dur = 0.08, vol = 0.04, type = "sine") {
            if (!AC || mute) return;
            const t0 = AC.currentTime, o = AC.createOscillator(), g = AC.createGain();
            o.type = type; o.frequency.value = freq;
            g.gain.setValueAtTime(vol, t0);
            g.gain.exponentialRampToValueAtTime(0.0001, t0 + dur);
            o.connect(g).connect(AC.destination); o.start(t0); o.stop(t0 + dur);
        }
        function winJingle() { [784, 880, 988, 1175].forEach((f, i) => setTimeout(() => beep(f, 0.14, 0.06, "triangle"), i * 130)); }

        // ---------- Helpers ----------
        function clampRadius() {
            const r = Math.floor(Math.min(W, H) / 2 - (PLANET_R + LABEL_SPACE + PAD));
            return Math.max(r, 60);
        }
        function pick(arr, i) { return arr[Math.abs(i) % arr.length]; }
        function lerp(a, b, u) { return a + (b - a) * u; }
        function easeOut(u) { return 1 - Math.pow(1 - u, 2); }
        const toIndex = (i) => (i + NUM_NODES) % NUM_NODES;

        // Scale shadow blurs a bit on HiDPI so theyâ€™re cheaper
        function sb(px) { return px * (DPR > 1 ? 0.7 : 1); }

        // ---------- Layout ----------
        function computePositions() {
            positions = [];
            planetNames = [];
            for (let i = 0; i < NUM_NODES; i++) {
                const theta = (2 * Math.PI * i) / NUM_NODES - Math.PI / 2;
                positions.push({
                    x: CENTER.x + RING_RADIUS * Math.cos(theta),
                    y: CENTER.y + RING_RADIUS * Math.sin(theta)
                });
                planetNames.push(pick(NAMES, i));
            }
        }

        // ---------- Star sprites (for richer, faster stars) ----------
        const starSprites = []; // 1..3
        function makeStarSprite(size) {
            const s = Math.max(2, size * 4); // tiny offscreen canvas
            const off = document.createElement('canvas');
            off.width = off.height = s;
            const g = off.getContext('2d');
            const r = s / 2;
            const grad = g.createRadialGradient(r, r, 0, r, r, r);
            grad.addColorStop(0, 'rgba(255,255,255,1)');
            grad.addColorStop(0.4, 'rgba(210,230,255,0.9)');
            grad.addColorStop(1, 'rgba(140,180,255,0)');
            g.fillStyle = grad;
            g.beginPath(); g.arc(r, r, r, 0, Math.PI * 2); g.fill();
            return off;
        }
        function getStarSprite(sz) {
            const s = Math.max(1, Math.min(3, Math.round(sz)));
            return starSprites[s] || (starSprites[s] = makeStarSprite(s));
        }

        // ---------- Background ----------
        function initStars() {
            stars.length = 0;
            const total = Math.round(Math.max(350, (W * H) / 5000)); // scale density with area
            for (let i = 0; i < total; i++) {
                const z = Math.random() * 1 + 0.2;                 // depth 0.2..1.2
                const layer = z < 0.5 ? 1 : (z < 0.9 ? 2 : 3);    // 3 parallax bands
                const size = layer;                               // 1..3
                stars.push({
                    x: Math.random() * W,
                    y: Math.random() * H,
                    z,
                    layer,
                    size,
                    tw: Math.random() * Math.PI * 2
                });
            }
        }

        function drawBackground(dt) {
            // nebula gradient
            const g = ctx.createRadialGradient(CENTER.x, CENTER.y, 60, CENTER.x, CENTER.y, Math.max(W, H));
            g.addColorStop(0, "#0e1020"); g.addColorStop(0.5, "#0a0f26"); g.addColorStop(1, "#070a14");
            ctx.fillStyle = g; ctx.fillRect(0, 0, W, H);

            // star field (parallax + twinkle, drawn with glow sprites)
            for (const s of stars) {
                const speed = (s.layer === 1 ? 0.006 : s.layer === 2 ? 0.012 : 0.02);
                s.x -= speed * dt * (DPR > 1 ? 1.1 : 1.0);
                if (s.x < -4) s.x += W + 8;

                const tw = (Math.sin(t * 0.004 + s.tw) * 0.5 + 0.5);
                const alpha = 0.25 + tw * (0.25 + 0.15 * s.layer); // brighter for closer layer
                ctx.globalAlpha = alpha;

                const spr = getStarSprite(s.size);
                const w = s.size * 4; // CSS pixels (mapped by DPR via setTransform)
                ctx.drawImage(spr, s.x - w / 2, s.y - w / 2, w, w);
            }
            ctx.globalAlpha = 1;

            // vignette
            const v = ctx.createRadialGradient(CENTER.x, CENTER.y, 0, CENTER.x, CENTER.y, Math.hypot(W, H) / 1.2);
            v.addColorStop(0, "rgba(0,0,0,0)"); v.addColorStop(1, "rgba(0,0,0,0.35)");
            ctx.fillStyle = v; ctx.fillRect(0, 0, W, H);
        }

        // ---------- Orbits ----------
        function drawOrbits() {
            ctx.save();
            ctx.lineWidth = 2; ctx.shadowBlur = sb(14);
            ctx.shadowColor = EDGE_COLOR; ctx.strokeStyle = EDGE_COLOR;
            for (let i = 0; i < NUM_NODES; i++) {
                const a = positions[i], b = positions[(i + 1) % NUM_NODES];
                ctx.beginPath(); ctx.moveTo(a.x, a.y); ctx.lineTo(b.x, b.y); ctx.stroke();
            }
            ctx.restore();
        }

        // ---------- Planets ----------
        function drawPlanet(x, y, on, phase, idx) {
            ctx.save();
            ctx.shadowBlur = on ? sb(24) : sb(16);
            ctx.shadowColor = on ? "rgba(255,180,120,.8)" : "rgba(120,170,255,.7)";
            const r = PLANET_R * (on ? (1 + 0.06 * Math.sin(phase)) : 1);
            const base = ctx.createRadialGradient(x - r * 0.3, y - r * 0.3, r * 0.1, x, y, r);
            if (on) { base.addColorStop(0, COLOR_ON_BASE); base.addColorStop(1, COLOR_ON_DEEP); }
            else { base.addColorStop(0, COLOR_OFF_BASE); base.addColorStop(1, COLOR_OFF_DEEP); }
            ctx.fillStyle = base; ctx.beginPath(); ctx.arc(x, y, r, 0, Math.PI * 2); ctx.fill();

            ctx.globalAlpha = 0.15;
            ctx.beginPath();
            for (let i = -3; i <= 3; i++) {
                const br = r * (0.5 + 0.08 * i + 0.02 * Math.sin((t * 0.003) + (x + y + i * 7)));
                ctx.moveTo(x - br, y); ctx.arc(x, y, br, 0, Math.PI * 2);
            }
            ctx.fillStyle = on ? "#ffe0c2" : "#c7dbff"; ctx.fill(); ctx.globalAlpha = 1;

            ctx.lineWidth = 2; ctx.strokeStyle = "rgba(255,255,255,0.12)";
            ctx.beginPath(); ctx.arc(x, y, r, 0, Math.PI * 2); ctx.stroke();

            ctx.font = `${Math.floor(r * 1.1)}px Apple Color Emoji, Segoe UI Emoji, Noto Color Emoji, system-ui`;
            ctx.textAlign = "center"; ctx.textBaseline = "middle"; ctx.globalAlpha = 0.95;
            ctx.fillText(on ? EMOJI_ON[(Math.floor(t / 400 + idx)) % EMOJI_ON.length] : EMOJI_OFF[idx % EMOJI_OFF.length], x, y + 1);
            ctx.globalAlpha = 1;

            ctx.font = "12px system-ui, -apple-system, Segoe UI, Roboto, Arial";
            ctx.textAlign = "center"; ctx.textBaseline = "top"; ctx.fillStyle = "rgba(230,235,255,.9)";
            ctx.fillText(planetNames[idx], x, y + r + 8);

            ctx.restore();
        }

        // ---------- FX (update + draw) ----------
        // ---------- FX (shorter, lighter) ----------
        // Shockwave: smaller start, faster growth, faster fade
        function addShockwave(x, y) {
            shockwaves.push({ x, y, r: PLANET_R * 0.7, alpha: 0.55 });
        }

        // Sparks: fewer particles, shorter life
        function addSparks(x, y, warm) {
            const n = 8; // was 16
            for (let i = 0; i < n; i++) {
                const ang = (Math.PI * 2 * i) / n + Math.random() * 0.6;
                const sp = 1.0 + Math.random() * 1.4; // slightly lower speed
                sparks.push({
                    x, y,
                    vx: Math.cos(ang) * sp,
                    vy: Math.sin(ang) * sp,
                    warm,
                    life: 0.9,                  // shorter lifetime (seconds-ish)
                    color: warm ? "#ffd2a0" : "#bfe0ff",
                    confetti: false,
                    rot: 0
                });
            }
        }

        // Update: time-based fade so itâ€™s consistent across devices
        function updateFX(dt) {
            // Shockwaves fade quickly and grow quickly
            for (let i = shockwaves.length - 1; i >= 0; i--) {
                const s = shockwaves[i];
                s.r += 240 * dt / 1000;                   // was 120
                s.alpha *= Math.pow(0.3, dt / 260);       // exponential fade; ~260ms half/third-life
                if (s.alpha < 0.05) shockwaves.splice(i, 1);
            }

            // Sparks: heavier damping + quicker life drop
            for (let i = sparks.length - 1; i >= 0; i--) {
                const p = sparks[i];
                p.x += p.vx * dt / 18;
                p.y += p.vy * dt / 18;
                // stronger damping so they don't travel far
                const damp = Math.pow(0.4, dt / 280);
                p.vx *= damp; p.vy *= damp;
                p.life -= dt / 220;                         // ~0.22s typical
                if (p.life <= 0) sparks.splice(i, 1);
            }

            // Completion rings unchanged (if you want those shorter too, tell me)
            for (let i = winRings.length - 1; i >= 0; i--) {
                const r = winRings[i];
                r.r += 200 * dt / 1000;
                r.alpha *= 0.985;
                if (r.alpha < 0.02) winRings.splice(i, 1);
            }

            // Keep particle count in check
            if (sparks.length > MAX_PARTICLES) sparks.splice(0, sparks.length - MAX_PARTICLES);
            if (shakeT > 0) shakeT -= dt;
        }

        // Draw: lower blur & line width so itâ€™s lighter on tablets/phones
        function drawFX() {
            // Shockwaves
            for (const s of shockwaves) {
                ctx.save();
                ctx.lineWidth = 2;                          // was 3
                ctx.globalAlpha = s.alpha;
                ctx.strokeStyle = "rgba(180,210,255,0.8)";
                ctx.shadowBlur = sb(12);                    // was 18
                ctx.shadowColor = "rgba(160,190,255,0.8)";
                ctx.beginPath(); ctx.arc(s.x, s.y, s.r, 0, Math.PI * 2); ctx.stroke();
                ctx.restore();
            }

            // Completion radiating rings (kept dramatic)
            for (const r of winRings) {
                ctx.save();
                ctx.globalAlpha = r.alpha;
                ctx.lineWidth = 6;
                ctx.strokeStyle = "rgba(255,160,60,0.9)";
                ctx.shadowBlur = 30;
                ctx.shadowColor = "rgba(255,120,40,0.9)";
                ctx.beginPath(); ctx.arc(CENTER.x, CENTER.y, r.r, 0, Math.PI * 2); ctx.stroke();
                ctx.restore();
            }

            // Sparks
            for (const p of sparks) {
                ctx.save();
                ctx.globalAlpha = Math.max(0, p.life);
                ctx.fillStyle = p.color;
                ctx.shadowBlur = sb(6);                     // was 10
                ctx.shadowColor = p.warm ? "rgba(255,180,120,.8)" : "rgba(160,200,255,.8)";
                ctx.fillRect(p.x, p.y, 2, 2);
                ctx.restore();
            }
        }



        // ---------- Pulses (visual signals) ----------
        function addPulse(a, b, durMs = NEIGHBOR_DELAY_MS) { pulses.push({ a, b, u: 0, durMs }); }
        function updatePulses(dt) {
            for (const p of pulses) { p.u += Math.max(0, dt) / p.durMs; }
            pulses = pulses.filter(p => p.u < 1.05);
        }
        function drawPulses() {
            ctx.save();
            for (const p of pulses) {
                const A = positions[p.a], B = positions[p.b];
                const u = Math.min(1, easeOut(p.u));
                const x = lerp(A.x, B.x, u), y = lerp(A.y, B.y, u);
                ctx.strokeStyle = "rgba(170,210,255,0.55)";
                ctx.lineWidth = 3; ctx.shadowBlur = sb(14);
                ctx.shadowColor = "rgba(150,190,255,0.9)";
                ctx.beginPath(); ctx.moveTo(A.x, A.y); ctx.lineTo(x, y); ctx.stroke();
                ctx.beginPath(); ctx.fillStyle = "rgba(220,240,255,0.95)";
                ctx.arc(x, y, 4, 0, Math.PI * 2); ctx.fill();
            }
            ctx.restore();
        }

        // ---------- Game logic ----------
        function setMessage() {
            msgEl.textContent = completed
                ? "Constellation ignited! Use the arrow to continue."
                : "Wake up all the planets! Tap a planet to toggle it and its neighbors.";
        }
        function startLevel() {
            NUM_NODES = LEVELS[levelIndex];
            RING_RADIUS = clampRadius();
            nodes = new Array(NUM_NODES).fill(0);
            moves = 0; completed = false;
            pulses = []; winRings.length = 0;
            computePositions();
            statusEl.textContent = `Level ${levelIndex + 1} â€” make all ${NUM_NODES} planets glow!`;
            setMessage();
        }
        function reset() { startLevel(); }

        function toggleIndex(idx) {
            idx = toIndex(idx);
            const turningOn = nodes[idx] === 0;
            const p = positions[idx];
            addShockwave(p.x, p.y);
            addSparks(p.x, p.y, turningOn);
            beep(turningOn ? 740 : 330, 0.06, 0.035, "sine");
            nodes[idx] ^= 1;
        }

        function toggleAt(i) {
            if (completed) return;
            resumeAC();
            toggleIndex(i);
            const L = toIndex(i - 1), R = toIndex(i + 1);
            addPulse(i, L); addPulse(i, R);
            setTimeout(() => { toggleIndex(L); checkWin(); }, NEIGHBOR_DELAY_MS);
            setTimeout(() => { toggleIndex(R); checkWin(); }, NEIGHBOR_DELAY_MS);
            moves++; statusEl.textContent = `Moves: ${moves}`;
            shakeT = SHAKE_FOR;
            checkWin();
        }

        function triggerWinFX() {
            for (let k = 0; k < 3; k++) { winRings.push({ r: 40 + k * 28, alpha: 0.9 }); }
            let bursts = 4;
            const spawn = () => { if (bursts-- <= 0) return; winRings.push({ r: 40, alpha: 0.9 }); setTimeout(spawn, 180); };
            setTimeout(spawn, 180);
            winJingle();
        }

        function checkWin() {
            if (!completed && nodes.every(v => v === 1)) {
                completed = true;
                statusEl.textContent = `Level ${levelIndex + 1} cleared in ${moves} moves`;
                setMessage();
                triggerWinFX();
            }
        }

        // ---------- Arrows ----------
        function rightArrowVisible() { return levelIndex === 0 && completed; } // level 6 after completion
        function leftArrowVisible() { return levelIndex === 1; }              // level 7 always
        function rightArrowRect() { return { x: W - ARROW_W - ARROW_PAD, y: (H - ARROW_H) / 2, w: ARROW_W, h: ARROW_H }; }
        function leftArrowRect() { return { x: ARROW_PAD, y: (H - ARROW_H) / 2, w: ARROW_W, h: ARROW_H }; }

        function drawArrow(rect, dir) { // dir: +1 right, -1 left
            ctx.save();
            const pulse = (Math.sin(t * 0.01) + 1) / 2;
            ctx.globalAlpha = 0.6 + pulse * 0.25;
            ctx.shadowColor = "rgba(180,220,255,0.9)";
            ctx.shadowBlur = sb(18);
            ctx.fillStyle = "rgba(170,210,255,0.9)";
            ctx.beginPath();
            const cx = rect.x + rect.w / 2, cy = rect.y + rect.h / 2;
            const w = rect.w * 0.9, h = rect.h * 0.7;
            if (dir > 0) {
                ctx.moveTo(cx - w * 0.4, cy - h / 2);
                ctx.lineTo(cx + w * 0.5, cy);
                ctx.lineTo(cx - w * 0.4, cy + h / 2);
            } else {
                ctx.moveTo(cx + w * 0.4, cy - h / 2);
                ctx.lineTo(cx - w * 0.5, cy);
                ctx.lineTo(cx + w * 0.4, cy + h / 2);
            }
            ctx.closePath(); ctx.fill();
            ctx.globalAlpha = 0.7; ctx.lineWidth = 3; ctx.strokeStyle = "rgba(80,120,200,0.8)"; ctx.stroke();
            ctx.restore();
        }

        function hitInRect(mx, my, r) { return mx >= r.x && mx <= r.x + r.w && my >= r.y && my <= r.y + r.h; }

        // ---------- Input ----------
        function localXY(e) {
            const r = canvas.getBoundingClientRect();
            return { x: e.clientX - r.left, y: e.clientY - r.top };
        }

        canvas.addEventListener("click", (e) => {
            const { x: mx, y: my } = localXY(e);
            if (rightArrowVisible() && hitInRect(mx, my, rightArrowRect())) { levelIndex = 1; startLevel(); return; }
            if (leftArrowVisible() && hitInRect(mx, my, leftArrowRect())) { levelIndex = 0; startLevel(); return; }
            const idx = hitTest(mx, my);
            if (idx !== -1) toggleAt(idx);
        });

        canvas.addEventListener("touchstart", (e) => {
            e.preventDefault();
            const touch = e.changedTouches[0];
            const r = canvas.getBoundingClientRect();
            const mx = touch.clientX - r.left, my = touch.clientY - r.top;
            if (rightArrowVisible() && hitInRect(mx, my, rightArrowRect())) { levelIndex = 1; startLevel(); return; }
            if (leftArrowVisible() && hitInRect(mx, my, leftArrowRect())) { levelIndex = 0; startLevel(); return; }
            const idx = hitTest(mx, my);
            if (idx !== -1) toggleAt(idx);
        }, { passive: false });

        resetBtn.addEventListener("click", () => startLevel());
        muteBtn.addEventListener("click", () => { mute = !mute; muteBtn.textContent = mute ? "ðŸ”‡" : "ðŸ”Š"; });

        function hitTest(mx, my) {
            const R = PLANET_R + 10, R2 = R * R;
            for (let i = 0; i < NUM_NODES; i++) {
                const p = positions[i], dx = mx - p.x, dy = my - p.y;
                if (dx * dx + dy * dy <= R2) return i;
            }
            return -1;
        }

        // ---------- Neon Level Number (changes on win) ----------
        function drawLevelNumber() {
            const n = LEVELS[levelIndex];
            const text = String(n);

            // Clip radius keeps the glow near the center only.
            // Use a fraction of the ring or screen so it works on any device.
            const clipR = Math.min(RING_RADIUS * 0.72, Math.min(W, H) * 0.34);

            ctx.save();
            // Clip the glow so it can't drift to the bottom node on mobile
            ctx.beginPath();
            ctx.arc(CENTER.x, CENTER.y, clipR, 0, Math.PI * 2);
            ctx.clip();

            ctx.textAlign = "center";
            ctx.textBaseline = "middle";

            // Scale font with screen
            const base = Math.min(W, H);
            const fontPx = Math.max(120, Math.floor(base * 0.28));
            ctx.font = `900 ${fontPx}px system-ui, -apple-system, Segoe UI, Roboto, Arial`;

            if (!completed) {
                const pulse = (Math.sin(t * 0.004) + 1) / 2;
                // Slightly reduce blur on mobile/HiDPI for perf and to limit spread
                const glow = (20 + pulse * 24) * (DPR > 1 ? 0.85 : 1);

                const grad = ctx.createLinearGradient(CENTER.x - 120, CENTER.y - 120, CENTER.x + 120, CENTER.y + 120);
                grad.addColorStop(0, "rgba(110,220,255,0.35)");
                grad.addColorStop(1, "rgba(120,120,255,0.35)");
                ctx.fillStyle = grad;

                ctx.shadowColor = "rgba(120,200,255,0.9)";
                ctx.shadowBlur = glow;

                // Fill + strokes
                ctx.globalAlpha = 0.85 * 0.25;
                ctx.fillText(text, CENTER.x, CENTER.y);

                ctx.globalAlpha = 0.35; ctx.lineWidth = 6; ctx.strokeStyle = "rgba(200,240,255,0.9)";
                ctx.strokeText(text, CENTER.x, CENTER.y);

                ctx.globalAlpha = 0.5; ctx.lineWidth = 2; ctx.strokeStyle = "rgba(255,255,255,0.9)";
                ctx.strokeText(text, CENTER.x, CENTER.y);

            } else {
                const pulse = (Math.sin(t * 0.012) + 1) / 2;
                const glow = (40 + pulse * 40) * (DPR > 1 ? 0.85 : 1);
                const scale = 1 + pulse * 0.02;

                ctx.translate(CENTER.x, CENTER.y);
                ctx.scale(scale, scale);

                const grad = ctx.createLinearGradient(-120, -120, 120, 120);
                grad.addColorStop(0, "rgba(255,170,70,0.55)");
                grad.addColorStop(1, "rgba(255,80,40,0.55)");
                ctx.fillStyle = grad;

                ctx.shadowColor = "rgba(255,120,40,0.95)";
                ctx.shadowBlur = glow;

                ctx.globalAlpha = 0.9;
                ctx.fillText(text, 0, 0);

                ctx.globalAlpha = 0.8; ctx.lineWidth = 8; ctx.strokeStyle = "rgba(255,220,180,0.95)";
                ctx.strokeText(text, 0, 0);

                ctx.globalAlpha = 1; ctx.lineWidth = 2; ctx.strokeStyle = "rgba(255,255,255,0.9)";
                ctx.strokeText(text, 0, 0);
            }

            ctx.restore();
        }
        // ---------- Arrows draw ----------
        function drawArrows() {
            if (rightArrowVisible()) drawArrow(rightArrowRect(), +1);
            if (leftArrowVisible()) drawArrow(leftArrowRect(), -1);
        }

        // ---------- Main Loop ----------
        let last = performance.now();
        function frame(now) {
            const dt = now - last; last = now; t = now;

            updateFX(dt);
            updatePulses(dt);

            ctx.save();
            if (shakeT > 0) ctx.translate((Math.random() * 2 - 1) * 3, (Math.random() * 2 - 1) * 3);

            drawBackground(dt);
            drawOrbits();
            drawLevelNumber();

            for (let i = 0; i < NUM_NODES; i++) {
                const p = positions[i];
                drawPlanet(p.x, p.y, nodes[i] === 1, t * 0.01 + i * 0.7, i);
            }

            drawPulses();
            drawFX();
            drawArrows(); // arrows render on top

            ctx.restore();
            requestAnimationFrame(frame);
        }

        // ---------- Init ----------
        function ready() {
            resizeCanvas();                       // size to screen + compute positions + stars
            startLevel();                         // all OFF, level 1 (6)
            requestAnimationFrame(frame);
        }
        ready();
        window.addEventListener('resize', resizeCanvas, { passive: true });
        window.addEventListener('orientationchange', resizeCanvas, { passive: true });
    </script>
</body>

</html>